#!/usr/bin/env perl
# positions2snv_invariant_alignment
# Purpose:  Given a snv_align-positions.tsv and a reference file, converts to an alignment, keeping all invariant positions.

use warnings;
use strict;

use Getopt::Long;
use Bio::AlignIO;
use Bio::SimpleAlign;
use Bio::LocatableSeq;
use Bio::SeqIO;
use Bio::Seq::SeqFactory;

my ($input,$output,$format,$keep,$reference_name,$reference_file,$verbose);
$verbose = 0;
$keep = 0;
my %valid_formats = ('phylip' => 1,'fasta' => 1);

sub usage
{
	"Usage: $0 -i [snv_align-positions.tsv] -o [snv_align out] -f [alignment format] [-v]\n".
	"Parameters:\n".
	"\t-i|--input:  Input file (snv_align-positions.tsv generated by snv pipeline)\n".
	"\t-o|--output-dir:  Output directory name (containing an alignment for each chromosome/sequence in reference file)\n".
	"\t-f|--format:  Alignment format (default phylip)\n".
	"\t--keep-all: Keep all positions in alignment\n".
	"\t--reference-file:  Reference file\n".
	"\t--verbose: Print more information\n";
}

# reads all reference sequences into a table structured like
# ref_id => seq_data
sub read_reference_sequences
{
	my ($reference_file) = @_;
	my %sequence_table;

	my $ref_io = Bio::SeqIO->new(-file=>"< $reference_file",-format=>"fasta");
	die "could not parse reference file $reference_file\n".usage if (not defined $ref_io);

	while (my $seq = $ref_io->next_seq)
	{
		$sequence_table{$seq->display_id} = $seq->seq;
	}

	return \%sequence_table;
}

if (!GetOptions('i|input=s' => \$input,
		'o|output-dir=s' => \$output,
		'f|format=s' => \$format,
		'keep-all' => \$keep,
		'reference-file=s' => \$reference_file,
		'v|verbose=s' => \$verbose))
{
	die "Invalid option\n".usage;
}

die "Error: no input file defined\n".usage if (not defined $input);
die "Error: file $input does not exist" if (not -e $input);
die "Error: no output file defined\n".usage if (not defined $output);
die "Error: output-dir=$output already exists\n".usage if (-e $output);

$format = 'phylip' if (not defined $format);
die "Error: format $format is not valid".usage if (not defined $valid_formats{$format});

print "Date: ".`date`;
print "Working on $input\n";

open(my $fh, "<$input") or die "Could not open $input: $!";

my $line = readline($fh);
chomp($line);

die "Error: no header line defined in $input" if ($line !~ /^#Chromosome\tPosition\tStatus\tReference/);
my @values = split(/\t/,$line);
my (undef,undef,undef,@strains) = @values;
die "Error: no strains defined in $input" if (@strains <= 0);

my %aligned_chromosomes;
my $valid_count=0;
my $invalid_count=0;

my $sequence_table = read_reference_sequences($reference_file);

# fills in initial sequence information from reference genome
for my $strain (@strains)
{
	for my $chrom (keys %$sequence_table)
	{
		$aligned_chromosomes{$chrom} = {} if (not defined $aligned_chromosomes{$chrom});
		$aligned_chromosomes{$chrom}{$strain} = $sequence_table->{$chrom};
	}
}

while(my $line = readline($fh))
{
	chomp $line;
	my @values = split(/\t/,$line);

	my ($chrom,$pos,$status,@dna) = @values;
	my $string_pos = $pos - 1;  # subtract 1 since string is 0-based and positions in table are 1-based

	if (scalar(@dna) != scalar(@strains))
	{
		die "Error: line $line does not have same number of entries as header for $input";
	}
	elsif ($status ne 'valid')
	{
		if (not $keep)
		{
			print STDERR "Skipping invalid line: $line\n" if ($verbose);
			$invalid_count++;
		}
		else
		{		
			$valid_count++;
			for (my $i = 0; $i < @dna; $i++)
			{
				my $seq_data = \$aligned_chromosomes{$chrom}{$strains[$i]};
				substr($$seq_data,$string_pos,1) = $dna[$i];
			}
		}
	}
	else
	{
		$valid_count++;
		for (my $i = 0; $i < @dna; $i++)
		{
			my $seq_data = \$aligned_chromosomes{$chrom}{$strains[$i]};
			substr($$seq_data,$string_pos,1) = $dna[$i];
		}
	}
}

close($fh);

#no valid positions were found so no point making empty file
if ( not $valid_count) {
    print "No valid positions were found. Not creating empty alignment file\n";
    exit;
}

mkdir ($output) if (not -e $output);

# generate seq objects
for my $chrom (keys %aligned_chromosomes)
{
	my $align = Bio::SimpleAlign->new(-source=>"NML Bioinformatics Core SNV Pipeline",-longid=>1);
	for (my $i = 0; $i < @strains; $i++)
	{
		my $seq_data = uc($aligned_chromosomes{$chrom}{$strains[$i]});
		my $seq = Bio::LocatableSeq->new(-seq => $seq_data, -id => $strains[$i], -start => 1, -end => length($seq_data));
		$align->add_seq($seq);
	}
	$align->sort_alphabetically;
	
	# build alignment
	my $output_name = "$output/$chrom.$format";
	my $io = Bio::AlignIO->new(-file => ">$output_name", -format => $format, -longid=>1);
	die "Error: could not create Align::IO object" if (not defined $io);
	$align->set_displayname_flat(1); #force to output only the display name and not length
	die "Error: alignment not flush" if (not $align->is_flush);
	$io->write_aln($align);
}

print "Using reference file $reference_file\n";
print "Kept $valid_count valid positions\n";
print "Skipped $invalid_count positions\n";
print "Alignments for each chromosome written to $output\n";
